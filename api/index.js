const express = require("express");
const { formatQuery } = require("react-querybuilder");
const db = require("./lib/db");
const PORT = process.env.PORT || 9000;

const app = express();

app.use(express.json());

// You could use an NGINX reverse proxy to overcome CORS issues.
app.use(function (_req, res, next) {
  res.header("Access-Control-Allow-Origin", process.env.CLIENT_APP_URL);
  res.header(
    "Access-Control-Allow-Headers",
    "Origin, X-Requested-With, Content-Type, Accept"
  );

  next();
});

app.get("/tables", async (_req, res) => {
  const data = await db.getAllTables();

  res.writeHead(200, { "Content-Type": "application/json" });

  return res.end(JSON.stringify({ data }));
});

// Replaces question marks in the parameterized SQL format generated by `react-querybuilder`'s `formatQuery` with `$1`, `$2`, etc. to adhere to `pg`'s parameterized query format.
const processSQL = (sql) => {
  let i = 0;
  return sql.replace(/\?/g, () => {
    i++;
    return `$${i}`;
  });
};

app.post("/api/records", async (req, res) => {
  const { query } = req.body;

  const { sql, params } = formatQuery(query, { format: "parameterized" });
  const whereClause = processSQL(sql);
  const selectRawData = `SELECT * FROM cp_squirrels WHERE ${whereClause}`;

  let data = [];

  try {
    data = (await db.query(selectRawData, params)).rows;
  } catch (error) {
    console.log(error);
    return res.json({ data: [], error });
  }

  return res.json({
    data,
    error: null,
  });
});

app.listen(PORT, () => {
  console.log(`LISTENING ON PORT: ${PORT}`);
});
